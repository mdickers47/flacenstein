#!/usr/bin/python
"""
Flacenstein ripper GUI form.  It is possible to run this class by
itself, if ripping is all you are doing.  Otherwise you want to start
the program by running flacapp.py.

This depends on (at least) the following binaries:
  cdparanoia, flac, metaflac

Also the following Python modules:
  musicbrainz2 CDDB DiscID wx wxversion

Copyright (C) 2005 Michael A. Dickerson.  Modification and
redistribution are permitted under the terms of the GNU General Public
License, version 2.
"""

# import wxversion
# wxversion.select('2.6')

# -*- coding: ANSI_X3.4-1968 -*-
# generated by wxGlade 0.3.5.1 on Thu Jan 27 22:41:19 2005

import fcntl
import musicbrainz2.disc as mbdisc
import musicbrainz2.webservice as mbws
import os
import popen2 # this will be better with subprocess in python 2.4
import re
import signal
import sys
import tempfile
import time
import urllib
import webbrowser
import wx

from flacenstein import amazon, flaclib, flaccfg, paranoia

# begin wxGlade: dependencies
# end wxGlade

# Don't delete work files, and only rip track 1.
TESTMODE = False

ID_MINNUM         = 100
ID_CHOOSETMPPATH  = 101
ID_CHOOSECOVERART = 102
ID_CHOOSEOUTPATH  = 103
ID_DETECTCD       = 104
ID_RIP            = 105
ID_CLOSE          = 106
ID_WEBBROWSER     = 107
ID_TIMER          = 108
ID_MAXNUM         = 120

CMD_SIZE = (80,25)

STATE_IDLE      = 0
STATE_RIPPING   = 1
STATE_ENCODING  = 2
STATE_CANCELLED = 3

IMAGE_FILTER = 'Image files (*.jpg,*.gif,*.png)|*.jpg;*.jpeg;*.gif;*.png' \
               '|All files (*)|*'

class cdinfo:
    """
    just a container where you can put the information collected from the
    musicbrainz or cddb lookup
    """
    def __init__(self):
        self.artist = ""
        self.album = ""
        self.titles = { }
        self.releasedate = ""

    def parseFromTags(self, t):
        """
        parses the Vorbis comments in a long multiline string, such as might
        be found in the 'tags' GUI text box
        """
        trackcount = 0
        self.titles = { }
        lines = re.split('\n', t)
        for l in lines:
            match = re.search('^ARTIST=(.*)$', l)
            if match: self.artist = match.group(1)
            match = re.search('^ALBUM=(.*)$', l)
            if match: self.album = match.group(1)
            match = re.search('^DATE=(.*)$', l)
            if match: self.releasedate = match.group(1)
            match = re.search('^TITLE\[?(\d*)\]?=(.*)$', l)
            if match:
                if match.group(1):
                    self.titles[match.group(1)] = match.group(2)
                else:
                    trackcount += 1
                    self.titles[trackcount] = match.group(1)

    def convertToTags(self):
        """
        creates Vorbis comment block from album info
        """
        t = "ARTIST=%s\n" % self.artist
        t += "ALBUM=%s\n" % self.album
        t += "DATE=%s\n" % self.releasedate
        keys = self.titles.keys()[:]
        keys.sort()
        for key in keys: t += "TITLE[%s]=%s\n" % (key, self.titles[key])
        return t


class frmRipper(wx.Frame):
    
    def __init__(self, *args, **kwds):
        # begin wxGlade: frmRipper.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.lblTempPath = wx.StaticText(self, -1, "Working path:",
                                         style=wx.ALIGN_RIGHT)
        self.txtTempPath = wx.TextCtrl(self, -1, "/tmp")
        self.cmdTempPath = wx.Button(self, ID_CHOOSETMPPATH, "...",
                                     style=wx.BU_LEFT)
        self.lblOutPath = wx.StaticText(self, -1, "Final output path:",
                                        style=wx.ALIGN_RIGHT)
        self.txtOutPath = wx.TextCtrl(self, -1, "")
        self.cmdOutPath = wx.Button(self, ID_CHOOSEOUTPATH, "...",
                                    style=wx.BU_LEFT)
        self.chkEject = wx.CheckBox(self, -1, "Eject CD when done")
        self.lblCoverArt = wx.StaticText(self, -1, "Cover Art (APPLICATION blocks):")
        self.bmpCoverArt = wx.StaticBitmap(self, -1, wx.EmptyBitmap(120, 120),
                                           style=wx.SIMPLE_BORDER)
        self.lblCoverArtFilename = wx.StaticText(self, -1, "None Selected")
        self.lblMimeType = wx.StaticText(self, -1, "application/unknown")
        self.lblCoverArtSize = wx.StaticText(self, -1, "0 bytes")
        self.cmdCoverArt = wx.Button(self, ID_CHOOSECOVERART, "...",
                                     style=wx.BU_LEFT)
        self.cmdDetectCD = wx.ToggleButton(self, ID_DETECTCD, "Detect CD")
        self.cmdRip = wx.ToggleButton(self, ID_RIP, "Rip")
        #self.cmdWebBrowser = wx.Button(self, ID_WEBBROWSER, "Look Up")
        self.cmdClose = wx.Button(self, ID_CLOSE, "Close")
        self.lblTags = wx.StaticText(self, -1, "Tags (VORBIS_COMMENT block):")
        self.txtTags = wx.TextCtrl(self, -1, "", style=wx.TE_MULTILINE)
        self.lblMessages = wx.StaticText(self, -1, "Messages:")
        self.txtMessages = wx.TextCtrl(self, -1, "", style=wx.TE_MULTILINE)
        self.lblProgress = wx.StaticText(self, -1, "Idle")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade

        wx.Log.SetActiveTarget(wx.LogTextCtrl(self.txtMessages))
        
        wx.EVT_BUTTON(self, ID_CHOOSECOVERART, self.OnChooseCoverArt)
        wx.EVT_BUTTON(self, ID_CHOOSETMPPATH,  self.OnChooseTmpPath)
        wx.EVT_BUTTON(self, ID_CHOOSEOUTPATH,  self.OnChooseOutPath)
        wx.EVT_TOGGLEBUTTON(self, ID_DETECTCD, self.OnDetectCD)
        wx.EVT_TOGGLEBUTTON(self, ID_RIP,      self.OnRip)
        wx.EVT_BUTTON(self, ID_CLOSE,          self.OnClose)
        wx.EVT_BUTTON(self, ID_WEBBROWSER,     self.OnWebBrowser)
        
        self.timer = wx.Timer(self, ID_TIMER)
        wx.EVT_TIMER(self, ID_TIMER, self.OnIdle)
        #wx.EVT_IDLE(self, self.OnIdle)
        
        self.coverart = None
        self.workdir = None
        self.cancelled = False
        self.cddevice = None
        
        self.txtTags.SetValue("Click Detect CD to fill in tag information\n" \
                              "automatically using the MusicBrainz database.\n\n" \
                              "Click Rip to start ripping.  You may still edit\n" \
                              "tags and select cover art after ripping has\n" \
                              "started.")
        
        self.setUIState(STATE_IDLE)
        self.CheckBinaries()

    def __set_properties(self):
        # begin wxGlade: frmRipper.__set_properties
        self.SetTitle("Flacenstein Ripper")
        self.txtTempPath.SetSize((200, 25))
        self.cmdTempPath.SetSize((25, 25))
        self.txtOutPath.SetSize((200, 25))
        self.cmdOutPath.SetSize((25, 25))
        self.bmpCoverArt.SetSize((120, 120))
        self.cmdCoverArt.SetSize((25, 25))
        self.cmdDetectCD.SetSize(CMD_SIZE)
        self.cmdRip.SetSize(CMD_SIZE)
        self.cmdClose.SetSize(CMD_SIZE)
        #self.cmdWebBrowser.SetSize(CMD_SIZE)
        self.txtTags.SetSize((375, 430))
        self.txtMessages.SetSize((375, 200))
        self.txtMessages.Enable(False)
        self.lblProgress.SetSize((375, 25))
        self.lblProgress.SetFont(wx.Font(12, wx.MODERN, wx.NORMAL, wx.BOLD))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: frmRipper.__do_layout
        sizForm = wx.BoxSizer(wx.VERTICAL)
        sizFormHorizontal = wx.BoxSizer(wx.HORIZONTAL)
        sizRightPane = wx.BoxSizer(wx.VERTICAL)
        sizLeftPane = wx.BoxSizer(wx.VERTICAL)
        sizButtons = wx.BoxSizer(wx.HORIZONTAL)
        sizCoverArt = wx.BoxSizer(wx.HORIZONTAL)
        sizCoverArtLabels = wx.BoxSizer(wx.VERTICAL)
        
        sizPaths = wx.FlexGridSizer(3, 3, 0, 0)
        sizPaths.Add(self.lblTempPath, 0, wx.ALL|wx.ALIGN_RIGHT|wx.ADJUST_MINSIZE, 5)
        sizPaths.Add(self.txtTempPath, 0, wx.ALL|wx.FIXED_MINSIZE, 5)
        sizPaths.Add(self.cmdTempPath, 0, wx.ALL|wx.FIXED_MINSIZE, 5)
        sizPaths.Add(self.lblOutPath, 0, wx.ALL|wx.ALIGN_RIGHT|wx.ADJUST_MINSIZE, 5)
        sizPaths.Add(self.txtOutPath, 0, wx.ALL|wx.FIXED_MINSIZE, 5)
        sizPaths.Add(self.cmdOutPath, 0, wx.ALL|wx.FIXED_MINSIZE, 5)
        sizPaths.Add((1, 1), 0, wx.FIXED_MINSIZE, 0)
        sizPaths.Add(self.chkEject, 0, wx.ALL, 5)
        sizPaths.Add((1, 1), 0, wx.FIXED_MINSIZE, 0)
        sizLeftPane.Add(sizPaths, 0, 0, 0)
        sizLeftPane.Add(self.lblCoverArt, 0, wx.ALL, 5)
        sizCoverArt.Add(self.bmpCoverArt, 0, wx.ALL|wx.ALIGN_CENTER_HORIZONTAL|wx.FIXED_MINSIZE, 8)
        sizCoverArtLabels.Add(self.lblCoverArtFilename, 0, wx.ALL, 5)
        sizCoverArtLabels.Add(self.lblMimeType, 0, wx.ALL, 5)
        sizCoverArtLabels.Add(self.lblCoverArtSize, 0, wx.ALL, 5)
        sizCoverArtLabels.Add(self.cmdCoverArt, 0, wx.ALL|wx.FIXED_MINSIZE, 5)
        sizCoverArt.Add(sizCoverArtLabels, 1, wx.EXPAND, 0)
        sizLeftPane.Add(sizCoverArt, 0, wx.EXPAND, 0)
        sizLeftPane.Add(self.lblMessages, 0, wx.ALL, 5)
        sizLeftPane.Add(self.txtMessages, 1, wx.ALL|wx.EXPAND, 5)
        sizLeftPane.SetItemMinSize(self.txtMessages, 375, 150)
        sizLeftPane.Add(self.lblProgress, 0, wx.ALL, 10)
        sizFormHorizontal.Add(sizLeftPane, 1, wx.EXPAND, 0)
        
        sizRightPane.Add(self.lblTags, 0, wx.ALL, 5)
        sizRightPane.Add(self.txtTags, 1, wx.ALL|wx.EXPAND, 5)
        sizButtons.Add(self.cmdDetectCD, 0, wx.ALL|wx.FIXED_MINSIZE, 5)
        sizButtons.Add(self.cmdRip, 0, wx.ALL|wx.FIXED_MINSIZE, 5)
        sizButtons.Add((10, 10), 1, wx.ALL|wx.FIXED_MINSIZE, 5)
        #sizButtons.Add(self.cmdWebBrowser, 0, wx.ALL|wx.FIXED_MINSIZE, 5)
        sizButtons.Add(self.cmdClose, 0, wx.ALL|wx.FIXED_MINSIZE, 5)
        sizRightPane.Add(sizButtons, 0, wx.ALL|wx.ALIGN_CENTER_HORIZONTAL, 5)
        
        sizFormHorizontal.Add(sizRightPane, 1, wx.EXPAND, 0)
        sizForm.Add(sizFormHorizontal, 1, wx.EXPAND, 0)
        self.SetAutoLayout(True)
        self.SetSizer(sizForm)
        sizForm.Fit(self)
        sizForm.SetSizeHints(self)
        self.Layout()
        # end wxGlade

    def CheckBinaries(self):
        """
        tests whether the various programs we need to run can be run, and
        self-desstructs if not.
        """
        msg = ''
        if not flaclib.check_binary('%s -v' % flaccfg.BIN_FLAC, 'flac [\d\.]+'):
            msg += 'Can\'t execute flac binary at %s\n' % flaccfg.BIN_FLAC
        if not flaclib.check_binary('%s --version' % flaccfg.BIN_METAFLAC, 'metaflac [\d\.]+'):
            msg += 'Can\'t execute metaflac binary at %s\n' % flaccfg.BIN_METAFLAC
        if not flaclib.check_binary('%s -V' % flaccfg.BIN_CDPARANOIA, \
                                    'cdparanoia III release [\d\.]+'):
            msg += 'Can\'t execute cdparanoia binary at %s\n' % flaccfg.BIN_CDPARANOIA
            
        if msg:
            m = wx.MessageDialog(self, msg, \
                                 'Fatal: One or more missing dependencies', \
                                 wx.OK | wx.ICON_ERROR)
            m.ShowModal()
            m.Destroy()
            self.Destroy()

    def OnChooseCoverArt(self, e):
        d = wx.FileDialog(self, "Select cover art image", "", "",
                          IMAGE_FILTER, wx.OPEN)
        if d.ShowModal() == wx.ID_OK:
            self.setCoverArt(os.path.join(d.GetDirectory(), d.GetFilename()))
        return

    def OnChooseOutPath(self, e):
        d = wx.DirDialog(self, "Choose final output path", "~")
        if d.ShowModal() == wx.ID_OK:
            self.txtOutPath.SetValue(d.GetPath())
        d.Destroy()
        return

    def OnChooseTmpPath(self, e):
        d = wx.DirDialog(self, "Choose temporary work path", "/tmp")
        if d.ShowModal() == wx.ID_OK:
            self.txtTempPath.SetValue(d.GetPath())
        d.Destroy()
        return

    def OnWebBrowser(self, e):
        pass

    def OnDetectCD(self, e):
        """
        this is what runs when the "Detect CD" button is clicked (believe it or
        not).  First we try to identify the CD using the musicbrainz library,
        then cddb, if that fails, then give up.
        """
        if self.cmdDetectCD.GetValue():
            self.goToWorkDir()
            if self.cddevice: wx.LogMessage("using CD device %s" % self.cddevice)
            wx.LogMessage("Checking musicbrainz for tags")
            wx.LogMessage("For information, see http://www.musicbrainz.org")
            info = None
            try:
                info = self._lookup_mb()
            except mbdisc.DiscError, e:
                wx.LogMessage("can't read disc: %s" % e)
                self.cmdDetectCD.SetValue(False)
                return

            if info == None:
                wx.LogMessage("musicbrainz failed, trying cddb")
                try:
                    info = self._lookup_cddb()
                except:
                    info = None
                    
            if info == None:  # nowhere else to look
                wx.LogMessage("nothing in cddb either: no tags available")
                info = cdinfo()
                # try to use musicbrainz library to at least find out the
                # number of tracks
                disc = mbdisc.readDisc(self.cddevice)
                for i in range(disc.firstTrackNum, disc.lastTrackNum + 1):
                    info.titles[i] = ""

            # get cover art from Amazon
            if info.artist and info.album:
                wx.LogMessage("searching Amazon for cover art")
                urls = None
                try:
                    info.releasedate, urls = amazon.LookupDisc(info.artist,
                                                               info.album)
                except amazon.NoAmazonKeys:
                    wx.LogMessage("not configured with amazon keys; skipping")

                # urls is a list, but we only bother with the first entry
                if urls:
                    data = urllib.urlopen(urls[0])
                    ext = os.path.splitext(urls[0])[1]
                    fd, imgfile = tempfile.mkstemp(ext, "amazon.", self.workdir)
                    os.write(fd, data.read())
                    os.close(fd)
                    self.setCoverArt(imgfile)
                else:
                    wx.LogMessage("no results from Amazon search")

            # fill out tags box
            self.txtTags.SetValue(info.convertToTags())

        else:
            # "undetect" CD
            self.txtTags.SetValue("")
        return

    def _lookup_mb(self):
        """
        throws an exception if the CD can't be read, returns None if the CD
        is ok but musicbrainz has nothing for us.
        """
        disc = mbdisc.readDisc(self.cddevice) # exception here if no cd
        try:
            # search by disc ID
            svc = mbws.WebService()
            q = mbws.Query(svc)
            matches = q.getReleases(mbws.ReleaseFilter(discId=disc.getId()))
            
            if len(matches) == 0:
                wx.LogMessage('no results from musicbrains')
                return None

            # go back for full details on the first match
            wx.LogMessage('musicbrains found %d matches' % len(matches))
            release = matches[0].release
            inc = mbws.ReleaseIncludes(artist=True, tracks=True,
                                       releaseEvents=True)
            release = q.getReleaseById(release.getId(), inc)
            
            isOneArtist = release.isSingleArtistRelease()
            ret = cdinfo()
            ret.artist = release.artist.getUniqueName()
            ret.album  = release.title
            # using the dictionary is gratuitous for musicbrainz, which
            # returns the titles in order, but cddb does not.
            i = 1
            for t in release.tracks:
                if isOneArtist or t.artist is None:
                    ret.titles[i] = t.title
                else:
                    ret.titles[i] = '%s-%s' % (t.artist.name, t.title)
                i += 1
                                
        except mbws.WebServiceError, e:
            wx.LogMessage('musicbrainz error: %s' % e)
            return None

        return ret

    def _lookup_cddb(self):
        """
        returns a cdinfo() instance containing the information we found in
        cddb, or None if that doesn't work.  This method doesn't intentionally
        throw any exceptions (unlike _lookup_mb) although I'm sure it's
        possible.
        """
        import DiscID, CDDB
        if self.cddevice: dev = DiscID.open(self.cddevice)
        else: dev = DiscID.open()
        cdid = DiscID.disc_id(dev)
        tracks = cdid[1]
        (status, info) = CDDB.query(cdid)
        if status == 200:
            (status, info) = CDDB.read(info['category'], \
                                       info['disc_id'])
        elif status == 210 or status == 211:
            (status, info) = CDDB.read(info[0]['category'], \
                                       info[0]['disc_id'])
        else:
            return None

        ret = cdinfo()
        for key in info.keys():
            if key.startswith('TTITLE'):
                n = int(re.findall("TTITLE([0-9]+)", key)[0])
                ret.titles[n] = info[key].encode('ascii', errors='replace')
            elif key == 'DTITLE':
                (artist, album) = info[key].split('/')
                ret.artist = artist.strip()
                ret.album = album.strip()
            elif key == 'DYEAR':
                ret.releasedate = info[key]
        wx.LogMessage("cddb succeeded")
        return ret    

    def OnRip(self, e):
        """
        starts a cdparanoia process, changes GUI state to 'ripping'
        """
        if not self.cmdRip.GetValue():
            # the button should really be disabled while ripping, but it looks
            # ugly next to an enabled button (Detect CD)
            wx.LogError("Click the Stop button if you want to interrupt ripping.")
            self.cmdRip.SetValue(True)
            return

        wx.LogMessage("preparing cue sheet")
        self._create_cue()
        
        # popen the cdparanoia process and set non-blocking reads on its output
        cmd = '%s -e' % flaccfg.BIN_CDPARANOIA
        if self.cddevice:
            cmd += '-d %s' % self.cddevice
        cmd += ' 1-'
        if TESTMODE:
            cmd += '2' # rip only track 1 to save a lot of time
            wx.LogMessage("TEST MODE active: Only ripping track 1!")
            wx.LogMessage("command is: %s" % cmd)
            
        self.child = popen2.Popen4(cmd)
        fcntl.fcntl(self.child.fromchild.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)
        self.childbuffer = ""
        wx.LogMessage("spawned cdparanoia process %d" % self.child.pid)
        self.setUIState(STATE_RIPPING)

    def OnClose(self, e):
        """
        closes the form, but not if ripping is going on
        """
        if self.state == STATE_IDLE:
            self.Destroy()
        else:
            self.state = STATE_CANCELLED

    def OnIdle(self, e):
        """
        Note that OnIdle() used to be installed as a wxWidgets "idle"
        handler, but that never worked reliably, so it is now fired from a
        timer and is thus misnamed.
        
        OnIdle() does different things depending on the current state:
        nothing in STATE_IDLE, or keep an eye on the child process
        doing the actual work in STATE_RIPPING or STATE_ENCODING.
        """        
        if self.state == STATE_IDLE:
            return
        elif self.state == STATE_CANCELLED:
            # kill child process, delete work directory, return to idle state
            wx.LogMessage("cancelled by user request")
            os.kill(self.child.pid, signal.SIGTERM)
            self.cleanUpWorkDir()
            self.setUIState(STATE_IDLE)
            self.timer.Stop()
            del self.child
            del self.childbuffer
            return

        # if we got here, we are waiting on either a ripper or encoder child
        self.updateProgress()
        ret = self.child.poll()

        if ret == -1:
            # child still running; just wait
            return

        # child exited: state change of some kind
        if self.state == STATE_RIPPING:
            if os.WEXITSTATUS(ret) == 0:
                # setting idle state sooner messes up lblProgress text
                self.setUIState(STATE_IDLE) # or idle handler will puke exceptions
                del self.child
                del self.childbuffer

                wx.LogMessage("cdparanoia finished successfully")
                
                # rip went ok, now set up the flac process and change state to
                # STATE_ENCODING
                
                if self.chkEject.GetValue():
                    cmd = "eject"
                    if self.cddevice: cmd += " " + self.cddevice
                    self.runCommand(cmd)
                        
                t = self.txtTags.GetValue()
                t += "RIPSTATUS=" + paranoia.getFinalStatus() + "\n"
                self.txtTags.SetValue(t)

                info = cdinfo()
                info.parseFromTags(self.txtTags.GetValue())

                if not (info.artist and info.album):
                    wx.LogError("missing artist or album tag; can't continue")
                    return
                f = flaclib.filequote(info.artist + " - " + info.album + ".flac")
                wx.LogMessage("output file is %s" % f)
                self.outfile = os.path.join(self.txtOutPath.GetValue(), f)

                self.goToWorkDir()
                cmd = "%s -o %s --delete-input-file -V " \
                      % (flaccfg.BIN_FLAC, flaclib.shellquote(self.outfile))
                cmd += " --padding 262144 cdda.wav"
                wx.LogMessage(cmd)
                self.child = popen2.Popen4(cmd)
                self.childbuffer = ""
                fcntl.fcntl(self.child.fromchild.fileno(), fcntl.F_SETFL,
                            os.O_NONBLOCK)
                wx.LogMessage("spawned flac process %d" % self.child.pid)
                self.setUIState(STATE_ENCODING)
                
            else:
                self.setUIState(STATE_IDLE)
                del self.child
                del self.childbuffer
                wx.LogMessage("cdparanoia exited with status %d" \
                              % os.WEXITSTATUS(ret))
                wx.LogMessage("Not cleaning up work directory %s" \
                              % self.workdir)
                
        elif self.state == STATE_ENCODING:
            self.setUIState(STATE_IDLE)
            del self.child
            del self.childbuffer                
            if os.WEXITSTATUS(ret) == 0:
                wx.LogMessage("encoder finished successfully")
            else:
                wx.LogError("encoder exited with status %d"
                            % os.WEXITSTATUS(ret))
                
            # use metaflac to load tags from text box.  We could have done
            # this with many -T arguments to flac, but then we would not
            # be able to edit them while the encoding is going on.
            wx.LogMessage("inserting tags")
            self.goToWorkDir()
            open("tags", "w").write(self.txtTags.GetValue().encode('utf8'))
            cmd = "%s --import-tags-from=tags " % flaccfg.BIN_METAFLAC
            cmd += flaclib.shellquote(self.outfile)
            self.runCommand(cmd)
                
            cmd = '%s --import-cuesheet-from=cue ' % flaccfg.BIN_METAFLAC
            cmd += flaclib.shellquote(self.outfile)
            self.runCommand(cmd)

            # use flacimage to insert image files
            wx.LogMessage("inserting cover art image")
            cmd = '%s --import-picture-from ' % flaccfg.BIN_METAFLAC
            cmd += flaclib.shellquote(self.coverart)
            cmd += " " + flaclib.shellquote(self.outfile)
            self.runCommand(cmd)
            del self.outfile
            if not TESTMODE: self.cleanUpWorkDir()

        return

    def _create_cue(self):
        self.goToWorkDir()

        info = cdinfo()
        info.parseFromTags(self.txtTags.GetValue())

        disc = mbdisc.readDisc(self.cddevice)

        # note that we had cdparanoia rip from track 1 to end of disc, so
        # we actually dropped the pregap to track 1 (which cdparanoia calls
        # track 0) in the rip (TO DO: is this a problem?).  So frame 0 of our
        # cdparanoia output is actually frame 0 of track 1.  Therefore for
        # our cuesheet to line up, we have to find out how long the dropped
        # pregap was (almost always 2 seconds as per CDDA standard) and
        # subtract that many frames from all of the track boundaries.
        #
        # Just to make this more fun, musicbrainz uses 1-based numbering
        # for tracks, so cdparanoia's track 1 is mb's track 2, etc.
        ##pregapoffset = int(mb.GetResultData1(MBE_TOCGetTrackSectorOffset, 2))
        
        cue = open('cue', 'w')
        cue.write('FILE "dummy.wav" WAVE\n')
        # The cuesheet specification allows TITLE and PERFORMER tags for
        # purposes of CD-TEXT, but there is no point generating them since
        # FLAC stores cuesheets in its own representation that preserves only
        # the seek points
        #cue.write('  TITLE "')
        #cue.write(info.album)
        #cue.write('"\n')
        #cue.write('  PERFORMER "')
        #cue.write(info.artist)
        #cue.write('"\n')
        pregapframes = disc.tracks[0][0]
        i = disc.firstTrackNum
        for (offset, length) in disc.tracks:
            cue.write('  TRACK %02d AUDIO\n' % i)
            offset -= pregapframes
            # It appears from the cdda specifications that:
            # 1 CD-ROM sector == 2352 bytes == 1 frame == 1/75 sec CDDA
            (secs, frames) = divmod(offset, 75)
            (mins, secs) = divmod(secs, 60)
##             if i in info.titles:
##                 cue.write('    TITLE "')
##                 cue.write(info.titles[i])
##                 cue.write('"\n')
            cue.write('    INDEX 01 %02d:%02d:%02d\n' % (mins, secs, frames))
            i += 1

        cue.close()
        return
        
    def updateProgress(self):
        try:
            s = self.child.fromchild.read()
            self.childbuffer += s
        except IOError:
            return
        
        if self.state == STATE_RIPPING:
            start = re.findall("from sector ([0-9 ]*)", self.childbuffer)
            end   = re.findall("to sector ([0-9 ]*)", self.childbuffer)
            if start and end:
                paranoia.setupStatus(int(start[0]), int(end[0]))
            msgs = re.findall("##: ([0-9\-]+) \[.*?\] @ ([0-9]+)$",
                              self.childbuffer)
            for m in msgs:
                paranoia.updateStatus(int(m[0]), int(m[1]))

            if msgs:
                self.childbuffer = ""
                self.lblProgress.SetLabel(paranoia.getStatus())
                
        elif self.state == STATE_ENCODING:
            pattern = "(\d+% complete, ratio=[0-9\.]+)"
            stats = re.findall(pattern, self.childbuffer)
            if stats:
                self.lblProgress.SetLabel(stats[len(stats) - 1])
                self.childbuffer = ""

        else:
            wx.LogError("internal error: updateProgress() in wrong state")

        return
    
    def setUIState(self, newstate):
        if newstate == STATE_IDLE:
            self.cmdClose.SetLabel("Close")
            self.cmdRip.SetValue(False)
            self.lblProgress.SetLabel("Idle.")
            self.txtTempPath.Enable(True)
            self.cmdTempPath.Enable(True)
            self.txtOutPath.Enable(True)
            self.cmdOutPath.Enable(True)
            self.timer.Stop()
            
        elif newstate == STATE_RIPPING:
            self.cmdClose.SetLabel("Stop")
            self.cmdRip.SetValue(True)
            self.lblProgress.SetLabel("Ripping...")
            self.txtTempPath.Enable(False)
            self.cmdTempPath.Enable(False)
            self.txtOutPath.Enable(True)
            self.cmdOutPath.Enable(True)
            self.timer.Start(250, wx.TIMER_CONTINUOUS) # start calls to OnIdle()

        elif newstate == STATE_ENCODING:
            self.cmdClose.SetLabel("Cancel")
            self.cmdRip.SetValue(True)
            self.lblProgress.SetLabel("Encoding...")
            self.txtTempPath.Enable(False)
            self.cmdTempPath.Enable(False)
            self.txtOutPath.Enable(False)
            self.cmdOutPath.Enable(False)
            self.timer.Start(250, wx.TIMER_CONTINUOUS) # start calls to OnIdle()

        else:
            wx.LogError("internal error: bad state argument")
        self.state = newstate
        return

    def goToWorkDir(self):
        if not (self.workdir and os.path.isdir(self.workdir)):
            d = tempfile.mkdtemp("", "rip.", self.txtTempPath.GetValue())
            self.workdir = os.path.join(self.txtTempPath.GetValue(), d)
            wx.LogMessage("created work directory %s" % self.workdir)
        os.chdir(self.workdir)
        return

    def cleanUpWorkDir(self):
        if not (self.workdir and os.path.isdir(self.workdir)):
            return
        try:
            for f in os.listdir(self.workdir):
                os.remove(f)
            os.rmdir(self.workdir)
            wx.LogMessage("deleted work directory %s" % self.workdir)
            self.workdir = None
        except OSError:
            wx.LogError("can't delete %s" % self.workdir)
        return

    def runCommand(self, cmd):
        ret = os.system(cmd)
        if TESTMODE:
            wx.LogMessage("running external command: %s" % cmd)
        if os.WEXITSTATUS(ret):
            wx.LogError("system command returned status %d" \
                        % os.WEXITSTATUS(ret))
            wx.LogError("failed command was: %s" % cmd)
        return ret == 0

    def setCoverArt(self, path):
        try:
            img = wx.Image(path, wx.BITMAP_TYPE_ANY)
            img.Rescale(120,120)
            self.bmpCoverArt.SetBitmap(wx.BitmapFromImage(img))
            self.lblCoverArtFilename.SetLabel(os.path.basename(path))
            l = path.lower()
            if l.endswith(".jpg") or l.endswith(".jpeg"):
                self.lblMimeType.SetLabel("image/jpeg")
            elif l.endswith(".gif"):
                self.lblMimeType.SetLabel("image/gif")
            elif l.endswith(".png"):
                self.lblMimeType.SetLabel("image/png")
            else:
                self.lblMimeType.SetLabel("image/unknown")
            self.lblCoverArtSize.SetLabel("%d bytes" % os.path.getsize(path))
            self.coverart = path
        except:
            wx.LogMessage("Can't load image file")

# end of class frmRipper

if __name__ == '__main__':
    """
    you can start up this class by itself if you want
    """
    app = wx.PySimpleApp()
    f = frmRipper(None, -1, "Flacenstein Ripper")
    if len(sys.argv) > 1: f.cddevice = sys.argv[1]
    f.Show(1)
    app.MainLoop()
    print "See You Space Cowboy"
